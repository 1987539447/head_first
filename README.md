# 策略模式
* 多用组合 少用继承
* 抽离封装变化部分。抽离算法族，算法的变化独立于使用的客户
* 针对接口编程

# 观察者模式
* 交互对象间解耦
* 对象间一对多依赖。一方的变化关联引起其它变化

# 装饰者模式
* 对扩展开放 对修改关闭
* 动态的扩展对象功能或增加责任
* 装饰者继承被装饰者的接口，来保持对象的一致性
* 装饰者持有被装饰者的引用，来附加功能

# 工厂模式
* 简单工厂和抽象工厂
* 简单工厂直接根据参数来创建不同的产品
* 抽象工厂提供抽象创建方法，由具体工厂子类实现；创建不同的产品族而不指名具体类型
* 依赖抽象不依赖具体

# 单例模式
* 常用于连接池或者资源池，生成单个或者指定个数的实例对象
* 通过静态对象初始化保证仅生成单个实例
* 通过优化后的非空检查-双重检查 延迟对象初始化

# 命令模式
* 将请求封装为对象
* invoker -- command -- receiver
* command持有receiver 来调用最终的操作
* invoker持有command 来发起调用
* 解耦请求者和执行者
* 队列、日志处理

# 适配器模式
* 将一种类型的对象适配为另外一种类型
* 适配器实现目标接口以提供一致性，同时持有被适配对象，来实现具体的接口方法
* 对象适配和类适配
* 让不同的对象兼容合作，适合用于重构

# 门面模式
* 封装 减少耦合 减少交互
* 提供统一接口来访问子系统中一群接口，提供简单 易用的统一接口
* 最少知道原则
* 自身范围内的对象和实例 方法调用保持在界限内

# 模版方法
* 别调用我，我去调用你
* 模版类定义业务处理的通用流程，变化和细节部分设置为抽象方法待子类实现
* 模版定义算法骨架，一些步骤实现延迟到子类
* 钩子函数为模版中定义的抽象函数，供子类根据自己需求实现，来控制模版中业务处理流程
* 排序方法，把具体排序中比较操作留给compareTo

# 迭代器模式
* 单一职责原则-->内聚：只完成一件事情--只有一件事会引起类改变
* 顺序访问一个聚合对象内的元素，而不用去暴露内部结构
* 使用集合框架的迭代器

# 组合模式
* 将对象组织成整体/部分的关系，通常为树形结构
* 组合对象使用统一的接口，使得客户端可以一致来处理
* 违背单一职责换取透明性
* 结合使用迭代和组合模式，在内部提供一种遍历方式

# 状态模式
* 根据状态的改变改变行为
* 封装每个状态下针对不同操作的响应，并触发状态的改变
* 上下文对象持有状态和当前状态
* 状态持有上下文，解耦状态间相互依赖

# 代理模式
* 静态代理和动态代理：直接定义代理类来包装指定类 -- 通过工具（jdk cglib）自动生成代理类
* 远程代理：代理远程对象，虚拟代理：在正式对象准备好之前，替代处理  保护代理：代理包装对象，控制对方法或属性的访问
* 为另一个对象提供替身或者占位符，以控制对象的访问

# 复合模式
* 结合使用多个模式来解决问题
* MVC架构中的模式复用：观察者模式 - 控制器和视图观察模型数据的变化；策略模式 - 控制器针对不同视图操作的策略 组合模式 - 视图组件的组织 适配器模式 - 将新的模型适配到已有视图

# 真实世界的模式
* 模式 - 某种情景下针对某问题的解决方案； 情景 - 问题 - 解决方案
* 模式类目
* 模式分类：创建型 - 行为型 - 结构型； 类 - 对象
* 需要的时候使用模式 - 重构的时候 - 自然的使用模式
* 反模式：不好的解决方案来解决问题

# 其他模式
* 桥接模式：抽象和实现放在不同的层次，以便于独立扩展
* 生成器模式：复杂结构或对象的构建，隐藏内部创建细节
* 责任链模式：解耦请求发送者和处理者，每个处理为单独模块，处理可以动态增加删除
* 轻量模式： 用一个对象管理多个虚拟对象实例，集中管理
* 解释器模式：语言语法解析；每个规则表示为一个类，可自由扩展规则
* 中介者模式： 减少对象间的依赖和交互，都和中介者对象交互
* 备忘录模式：缓存当前状态、对象，以便于随时恢复； 维护关键对象状态、关键对象的封装
* 原型模式：简化对象创建，通过clone生成新实例，隐藏复杂创建的细节
* 访问者模式： 为组合对象增加新功能，无需改变结构。访问者知道如何去遍历对象
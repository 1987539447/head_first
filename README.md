# 策略模式
* 多用组合 少用继承
* 抽离封装变化部分。抽离算法族，算法的变化独立于使用的客户
* 针对接口编程

# 观察者模式
* 交互对象间解耦
* 对象间一对多依赖。一方的变化关联引起其它变化

# 装饰者模式
* 对扩展开放 对修改关闭
* 动态的扩展对象功能或增加责任
* 装饰者继承被装饰者的接口，来保持对象的一致性
* 装饰者持有被装饰者的引用，来附加功能

# 工厂模式
* 简单工厂和抽象工厂
* 简单工厂直接根据参数来创建不同的产品
* 抽象工厂提供抽象创建方法，由具体工厂子类实现；创建不同的产品族而不指名具体类型
* 依赖抽象不依赖具体

# 单例模式
* 常用于连接池或者资源池，生成单个或者指定个数的实例对象
* 通过静态对象初始化保证仅生成单个实例
* 通过优化后的非空检查-双重检查 延迟对象初始化

# 命令模式
* 将请求封装为对象
* invoker -- command -- receiver
* command持有receiver 来调用最终的操作
* invoker持有command 来发起调用
* 解耦请求者和执行者
* 队列、日志处理

# 适配器模式
* 将一种类型的对象适配为另外一种类型
* 适配器实现目标接口以提供一致性，同时持有被适配对象，来实现具体的接口方法
* 对象适配和类适配
* 让不同的对象兼容合作，适合用于重构

# 门面模式
* 封装 减少耦合 减少交互
* 提供统一接口来访问子系统中一群接口，提供简单 易用的统一接口
* 最少知道原则
* 自身范围内的对象和实例 方法调用保持在界限内

# 模版方法
* 别调用我，我去调用你
* 模版类定义业务处理的通用流程，变化和细节部分设置为抽象方法待子类实现
* 模版定义算法骨架，一些步骤实现延迟到子类
* 钩子函数为模版中定义的抽象函数，供子类根据自己需求实现，来控制模版中业务处理流程
* 排序方法，把具体排序中比较操作留给compareTo